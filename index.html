<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heart Holo - High Res</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020202;
            font-family: 'Segoe UI', sans-serif;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #input_video {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 180px;
            height: 135px;
            z-index: 2;
            border-radius: 10px;
            transform: scaleX(-1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 3;
            color: white;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .highlight {
            color: #ff9900;
            font-weight: bold;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 10;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>

<body>
    <div id="loading">Loading High-Res Holo...</div>
    <div id="ui-layer">
        <h1>Happy Valentines day Tanisha Baby</h1>
        <div id="status-text">Initializing...</div>
        <div
            style="margin-top:10px; background: rgba(0,0,0,0.4); padding: 10px; border-radius: 5px; font-size: 0.8rem;">
            <div>• <span class="highlight">2 Fingers:</span> Natural Heart</div>
            <div>• <span class="highlight">3 Fingers:</span> Expand & Prepare Images</div>
            <div>• <span class="highlight">Pinch (in 3-Finger):</span> Cycle & View Image Clear</div>
        </div>
    </div>

    <video id="input_video"></video>

    <script id="vertexShader" type="x-shader/x-vertex">
        uniform float uTime;
        uniform float uScale;
        uniform float uTemplate; 
        attribute vec3 aRandom;
        varying vec3 vColor;

        void main() {
            float phi = aRandom.x * 3.14159 * 2.0;
            float x = 16.0 * pow(sin(phi), 3.0);
            float y = 13.0 * cos(phi) - 5.0 * cos(2.0*phi) - 2.0 * cos(3.0*phi) - cos(4.0*phi);
            vec3 heartPos = vec3(x, y, aRandom.z * 3.0);
            
            vec3 finalPos = heartPos;
            if(uTemplate == 0.0) finalPos *= 0.6; 
            else finalPos *= 1.2;

            finalPos *= uScale;
            vColor = vec3(1.0, 0.4 + aRandom.y * 0.2, 0.1);

            vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
            gl_PointSize = (4.0 * uScale) * (20.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vColor;
        void main() {
            float r = distance(gl_PointCoord, vec2(0.5));
            if(r > 0.5) discard;
            float strength = pow(1.0 - r*2.0, 2.0);
            gl_FragColor = vec4(vColor, strength);
        }
    </script>

    <script>
        // --- 1. SCENE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 50;

        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
            precision: 'highp' // High precision for sharper rendering
        });

        // FIX: Set pixel ratio for high-density screens (Retina)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 2. IMAGE SYSTEM ---
        const imageUrls = [
            'https://i.ibb.co.com/bjSH9g52/b43d2626-0fda-4694-a22f-a3cb00df999e.jpg',
            'https://i.ibb.co.com/5xWN9K2d/1a931257-4b98-4c88-8c1a-6bc3a1e7238b.jpg',
            'https://i.ibb.co.com/vx906T2g/2025bbdd-c420-4b1d-9dfb-e0967bb99cec.jpg',
            'https://i.ibb.co.com/zhqhTgqC/357c7b55-64a0-4225-b56a-becec9057b84.jpg',
            'https://i.ibb.co.com/dJMhGxkS/f7b32612-e7d5-4415-aea0-f17e17bcdbab.jpg',
            'https://i.ibb.co.com/nMHzHGdM/b8b83979-214e-4a4e-8878-f26ca8afe8c9.jpg'
        ];

        const imageMeshes = [];
        const loader = new THREE.TextureLoader();
        const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();

        for (let i = 0; i < 6; i++) {
            const texture = loader.load(imageUrls[i]);

            // FIX: Sharpen the texture settings
            texture.anisotropy = maxAnisotropy; // Maximum sharpness
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = true;

            const geom = new THREE.PlaneGeometry(8, 8);
            const mat = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geom, mat);
            scene.add(mesh);
            imageMeshes.push(mesh);
        }

        // --- 3. PARTICLE SYSTEM ---
        const count = 25000;
        const geo = new THREE.BufferGeometry();
        const randoms = new Float32Array(count * 3);
        for (let i = 0; i < count * 3; i++) randoms[i] = (Math.random() - 0.5) * 2;
        geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(count * 3), 3));
        geo.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));

        const material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: { uTime: { value: 0 }, uScale: { value: 1 }, uTemplate: { value: 0 } },
            transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
        });
        const particles = new THREE.Points(geo, material);
        scene.add(particles);

        // --- 4. LOGIC STATE ---
        let currentImgIdx = 0;
        let isPinching = false;
        let wasPinching = false;
        let animTime = 0;
        let mode = 2;

        function updateImages(fingers) {
            imageMeshes.forEach((mesh, i) => {
                if (fingers === 3) {
                    const angle = (i / 6) * Math.PI * 2;
                    const radius = 25;

                    if (isPinching && i === currentImgIdx) {
                        mesh.position.lerp(new THREE.Vector3(0, 0, 15), 0.15); // Moved closer to camera
                        mesh.scale.lerp(new THREE.Vector3(2.5, 2.5, 1), 0.15);
                        mesh.material.opacity = 1.0;
                    } else {
                        const targetPos = new THREE.Vector3(Math.cos(angle) * radius, Math.sin(angle) * radius, 0);
                        mesh.position.lerp(targetPos, 0.1);
                        mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                        mesh.material.opacity = 0.3;
                    }
                    mesh.visible = true;
                }
                else if (fingers === 4) {
                    animTime += 0.005;
                    const angle = ((i / 6) * Math.PI * 2) + animTime;
                    const radius = 25;
                    const targetPos = new THREE.Vector3(Math.cos(angle) * radius, Math.sin(angle) * radius, 0);
                    mesh.position.lerp(targetPos, 0.05);
                    mesh.material.opacity = 0.8;
                    mesh.visible = true;
                }
                else {
                    mesh.position.lerp(new THREE.Vector3(0, 0, 0), 0.2);
                    mesh.material.opacity -= 0.05;
                    if (mesh.material.opacity <= 0) mesh.visible = false;
                }
            });
        }

        // --- 5. MEDIAPIPE ---
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                document.getElementById('status-text').innerText = "Holo Link Active";

                let fingers = 0;
                if (landmarks[8].y < landmarks[6].y) fingers++;
                if (landmarks[12].y < landmarks[10].y) fingers++;
                if (landmarks[16].y < landmarks[14].y) fingers++;
                if (landmarks[20].y < landmarks[18].y) fingers++;
                mode = fingers + 1;

                const dist = Math.sqrt(Math.pow(landmarks[4].x - landmarks[8].x, 2) + Math.pow(landmarks[4].y - landmarks[8].y, 2));
                isPinching = dist < 0.06;

                if (isPinching && !wasPinching && mode === 3) {
                    currentImgIdx = (currentImgIdx + 1) % 6;
                }
                wasPinching = isPinching;

                material.uniforms.uTemplate.value = (mode >= 3) ? 1.0 : 0.0;
                updateImages(mode);
            } else {
                document.getElementById('status-text').innerText = "Searching for Hand...";
            }
        }

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        const cameraFeed = new Camera(document.getElementById('input_video'), {
            onFrame: async () => { await hands.send({ image: document.getElementById('input_video') }); },
            width: 1280, height: 720 // High res camera input
        });
        cameraFeed.start().then(() => document.getElementById('loading').style.display = 'none');

        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.uTime.value += 0.02;
            particles.rotation.y += 0.005;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        });
    </script>
</body>

</html>